<!DOCTYPE html>
<html>
<head>
<title>Objets : héritage - principes</title>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<link rel="stylesheet" href="../_local/codemirror.css">
<script src="../_local/codemirror_pour_php.js"></script>

<link rel="stylesheet" href="../_core/def.css">
<script>
	if (top.FP) {
		document.addEventListener('DOMContentLoaded', top.FP.initPage, false);
	} else {
		location.replace('../index.html?x=' + encodeURI(location.href));
	}
</script>
</head>
<body>
	<div id="MENU-top"></div>
	<nav id="MENU-tuto"></nav>

	<div id="PAGE-tuto">
		<header></header>
		<ul id="MENU-page"></ul>

		<p>L'héritage comme l'encapsulation est un des principes fondamentaux de le programmation
			objet.</p>

		<p>
			Un héritage est défini par la relation "est un" ou "est une" : une voiture est un véhicule, une
			guitare est un instrument de musique, PHP est un langage informatique.
			<br>
			Cette relation n'est pas symétrique : tous les véhicules ne sont pas des voitures, tous les
			instruments de musique ne sont pas des guitares et tous les programmes ne sont pas écrits en PHP.
		</p>

		<h3>Principes</h3>
		<section>
			<p class="fp-cadre">
				L'héritage permet de <strong>réutiliser du code</strong> et de définir de nouvelles classes à
				partir de classes existantes.
			</p>

			<p>
				On va donc utiliser le code déjà écrit et testé d'une première classe (la <strong>classe
					de base</strong>) et ajouter de nouvelles fonctionnalités dans une seconde classe (la <strong>classe
					dérivée</strong>).
			</p>

			<p class="fp-puce">
				La <strong>classe de base</strong> est également appelée <strong>classe mère</strong> ou encore
				<strong>super-classe</strong>. Les 3 termes sont synonymes.
			</p>

			<p class="fp-puce">
				La <strong>classe dérivée</strong> est également appelée <strong>classe fille</strong> ou encore
				<strong>sous-classe</strong>. Les 3 termes sont synonymes.
			</p>

			<p class="fp-cadre">
				La relation entre la classe mére et la classe fille se fait avec le mot-clé <strong><code>extends</code></strong>
				placé entre le nom des classes dans la définition de la classe fille.
			</p>

			<figure>
				<img src="../phpimg/poo_12.png" width="497" height="216">
				<figcaption>syntaxe de extends</figcaption>
			</figure>

			<p class="fp-puce">
				On dit que La classe fille <strong>hérite</strong> de la classe mére. Elle bénéficie de tous les
				attributs et de toutes les méthodes de la classe mére, si ils/elles ne sont pas <code>private</code>.
			</p>


			<p class="fp-puce">
				Pour qu'une classe fille puisse atteindre les attributs de sa classe mère, les attributs dans la
				classe mère doivent être <code>protected</code> ou <code>public</code> (à éviter).
			</p>


			<p class="fp-puce">
				Pour qu'une classe fille puisse invoquer les méthodes de sa classe mère, les méthodes dans la
				classe mère doivent être <code>public</code> ou <code>protected</code>.
			</p>

			<table class="TAB-sans-bord">
				<tr>
					<td>
						<p>
							Dans l'exemple suivant, nous allons étendre la classe Guitare pour qu'on puisse aussi gérer
							des guitares électriques. Par rapport aux guitares de notre classe Guitare, une guitare
							électrique a deux attributs supplémentaires : <code>micros</code> pour définir le nombre de
							micros et <code>vibrato</code> pour définir si la guitare est équipée ou non d'un vibrato.
							<br>
							Remarque 1 : par souci de simplification du code, les valeurs passées aux constructeurs ne
							sont pas validées (il faudrait bien sûr le faire dans un développement réel).
							<br>
							Remarque 2 : les attributs de la classe mère Guitare sont passés en visibilité <code>protected</code>
							pour que la classe fille GuitareElectrique puisse les atteindre.
						</p>
					</td>
					<td style="vertical-align: middle">
						<figure>
							<img src="../phpimg/poo_19.png" width="279" height="276">
							<figcaption>héritage décrit avec le formalisme UML</figcaption>
						</figure>
					</td>
				</tr>
			</table>

			<form action="" method="post" class="TEST-form">
				<a class="TEST-lien" onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_13.html')"
					title="Afficher la bibliothéque de fonctions"></a>

				<div class="TEST-titre">
					<strong>Exemple</strong> : étendre une classe mère
				</div>
				<textarea name="txtCode" class="TEST-textarea" data-wrap>
&lt;?php
ob_start();
require('bib_fonctions.php');

class Guitare {
	protected $modele, $prix, $cordes, $remise, $son;

	const SON_A = 'acoustique';
	const SON_EA = 'électro-acoustique';
	const SON_R = 'à résonnateur';
	const SON_E = 'électrique';

	public function __construct($p1, $p2, $p3, $p4) {
		$this-&gt;modele = $p1;
		$this-&gt;prix = $p2;
		$this-&gt;cordes = $p3;
		$this-&gt;son = $p4;
		$this-&gt;remise = 0;
	}
	
	public function decrire() {
		echo '&lt;h4&gt;Guitare ', $this-&gt;son, '&lt;/h4&gt;',
				$this-&gt;modele, '&lt;br&gt;',
				$this-&gt;cordes, ' cordes&lt;br&gt;',				
				$this-&gt;prix, ' &amp;euro;';			
	}
}			// Fin de la classe Guitare	

class GuitareElectrique extends Guitare {
	private $micros, $vibrato;
	
	public function __construct($p1, $p2, $p3, $p4, $p5) {
		$this-&gt;modele = $p1;
		$this-&gt;prix = $p2;
		$this-&gt;cordes = $p3;
		$this-&gt;micros = $p4;
		$this-&gt;vibrato = $p5;
		$this-&gt;son = parent::SON_E;
		$this-&gt;remise = 0;		
	}		
}			// Fin de la classe GuitareElectrique
				
htmlDebut('Etendre une classe mére');

$g1 = new Guitare('Gretsch Falcon', 599, 12, Guitare::SON_A);
$g1-&gt;decrire();

$g2 = new GuitareElectrique('Gibson SG', 689, 6, 2, false);
$g2-&gt;decrire();

$g3 = new GuitareElectrique('Fender Strat', 609, 6, 3, true);
$g3-&gt;decrire();

htmlFin();
?&gt;</textarea>
			</form>

			<p>
				Le constructeur de la classe mère n'est <strong>pas appelé automatiquement</strong> quand on
				instancie la classe fille. Si nécessaire il doit être appelé explicitement dans le constructeur
				de la classe fille. On utilise alors l'opérateur de résolution de portée <code>::</code> précédé
				du mot-cle <code>parent</code>. On a fait la même chose dans l'exemple précédent pour faire
				référence dans la classe fille à la constante <code>SON_E</code> de la classe mère.
			</p>

			<form action="" method="post" class="TEST-form">
				<a class="TEST-lien" onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_13.html')"
					title="Afficher la bibliothéque de fonctions"></a>

				<div class="TEST-titre">
					<strong>Exemple</strong> : utiliser le constructeur de la classe mère
				</div>
				<textarea name="txtCode" class="TEST-textarea" data-wrap>
&lt;?php
ob_start();
require('bib_fonctions.php');

class Guitare {
	protected $modele, $prix, $cordes, $remise, $son;

	const SON_A = 'acoustique';
	const SON_EA = 'électro-acoustique';
	const SON_R = 'à résonnateur';
	const SON_E = 'électrique';

	public function __construct($p1, $p2, $p3, $p4) {
		$this-&gt;modele = $p1;
		$this-&gt;prix = $p2;
		$this-&gt;cordes = $p3;
		$this-&gt;son = $p4;
		$this-&gt;remise = 0;
	}
	
	public function decrire() {
		echo '&lt;h4&gt;Guitare ', $this-&gt;son, '&lt;/h4&gt;',
				$this-&gt;modele, '&lt;br&gt;',
				$this-&gt;cordes, ' cordes&lt;br&gt;',				
				$this-&gt;prix, ' &amp;euro;';		
	}
}			// Fin de la classe Guitare	

class GuitareElectrique extends Guitare {
	private $micros, $vibrato;
	
	public function __construct($p1, $p2, $p3, $p4, $p5) {
		parent::__construct($p1, $p2, $p3, parent::SON_E);
		$this-&gt;micros = $p4;
		$this-&gt;vibrato = $p5;	
	}		
}			// Fin de la classe GuitareElectrique
				
htmlDebut('Utiliser le constructeur de la classe mére');

$g1 = new Guitare('Gretsch Falcon', 599, 12, Guitare::SON_A);
$g1-&gt;decrire();

$g2 = new GuitareElectrique('Gibson SG', 689, 6, 2, false);
$g2-&gt;decrire();

$g3 = new GuitareElectrique('Fender Strat', 609, 6, 3, true);
$g3-&gt;decrire();

htmlFin();
?&gt;</textarea>
			</form>

			<p class="fp-cadre">
				L'héritage multiple n'est pas possible : une classe fille ne peut pas avoir plusieurs classes
				méres.
				<br>
				Une classe mère peut quant à elle avoir plusieurs classe filles.
				<br>
				L'héritage multi-niveaux est possible : une classe fille peut avoir une classe mère, une classe
				grand-mère, une classe arrière grand-mére, etc.
				<br>
			</p>
			<figure style="float: right; margin: 0">
				<img src="../phpimg/poo_17.png" width="148" height="462">
			</figure>

			<figure>
				<img src="../phpimg/poo_14.png" width="334" height="207">
			</figure>
			<figure>
				<img src="../phpimg/poo_15.png" width="403" height="211">
				<figcaption>héritage</figcaption>
			</figure>


		</section>

		<h3>Extension, spécialisation</h3>
		<section>
			<p class="fp-puce">
				L'ajout de fonctionnalités dans la classe fille se fait en y ajoutant des nouvelles
				caractéristiques (ie des nouveaux attributs) et des nouvelles actions (ie des nouvelles
				méthodes. La classe fille <strong>étend</strong> ainsi les capacités de la classe mére. On dit
				également qu'une classe fille est une spécialisation de la classe mére : elle "travaille" sur un
				domaine plus pointu que la classe mére.
			</p>

			<p class="fp-puce">Dans l'exemple précédent on a ajouté 2 nouveaux attributs à la classe
				mére. Il suffit de les définir dans la classe fille comme n'importe quel autre attribut.
				Remarque : une classe mére n'a pas accès aux nouveaux attributs définis dans sa classe fille, et
				ce, quelque soit la visibilité de ces attributs.</p>

			<p class="fp-puce">Pour ajouter de nouvelle méthodes à la classe fille, il suffit de les
				définir comme n'importe quelle autre méthode. Remarque : une classe mére n'a pas accès aux
				nouvelles méthodes définies dans sa classe fille, et ce, quelque soit la visibilité de ces
				attributs.</p>

			<figure style="float: right;margin: 0 0 0 2em">
				<img src="../phpimg/poo_20.png" width="134" height="278">
			</figure>
			<p>
				A titre d'exemple, nous allons ajouter une nouvelle méthode dans la classe fille
				GuitareElectrique. Cette méthode s'appelle <code>getMedias()</code> et donnera le code HTML pour
				afficher une photo de la guitare et jouer un extrait sonore.
			</p>
			<p>
				Le nom des fichiers est fait par transformation de l'attribut <code>modele</code> auquel on
				ajoute l'extension .jpg pour les images et .mp3 pour l'audio. Les fichiers images sont le
				répertoire visuel et les fichiers audio dans le répertoire audio.
			</p>
			<p>Le code de la méthode est le suivant :</p>

			<pre data-code="PHP">
public function getMedias() {
	$fichier = str_replace(' ', '_', $this-&gt;modele);
	$fichier = strtolower($fichier);
	return "&lt;div&gt;&lt;img src=visuels/$fichier.jpg&gt;
			&lt;audio src=audio/$fichier.mp3 controls
			style='width: 100px'&gt;&lt;/audio&gt;&lt;/div&gt;";
}</pre>

			<form action="" method="post" class="TEST-form">
				<a class="TEST-lien" onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_13.html')"
					title="Afficher la bibliothéque de fonctions"></a>

				<div class="TEST-titre">
					<strong>Exemple</strong> : Méthode spécifique dans la classe fille
				</div>
				<textarea name="txtCode" class="TEST-textarea" data-wrap>
&lt;?php
ob_start();
require('bib_fonctions.php');

class Guitare {
	protected $modele, $prix, $cordes, $remise, $son;

	const SON_A = 'acoustique';
	const SON_EA = 'électro-acoustique';
	const SON_R = 'à résonnateur';
	const SON_E = 'électrique';

	public function __construct($p1, $p2, $p3, $p4) {
		$this-&gt;modele = $p1;
		$this-&gt;prix = $p2;
		$this-&gt;cordes = $p3;
		$this-&gt;son = $p4;
		$this-&gt;remise = 0;
	}
	
	public function decrire() {
		echo '&lt;h4&gt;Guitare ', $this-&gt;son, '&lt;/h4&gt;',
				$this-&gt;modele, '&lt;br&gt;',
				$this-&gt;cordes, ' cordes&lt;br&gt;',				
				$this-&gt;prix, ' &amp;euro;';		
	}
}			// Fin de la classe Guitare	

class GuitareElectrique extends Guitare {
	private $micros, $vibrato;
	
	public function __construct($p1, $p2, $p3, $p4, $p5) {
		parent::__construct($p1, $p2, $p3, parent::SON_E);
		$this-&gt;micros = $p4;
		$this-&gt;vibrato = $p5;	
	}
	
	public function getMedias() {
		$fichier = str_replace(' ', '_', $this-&gt;modele);
		$fichier = strtolower($fichier);
		return "&lt;div&gt;&lt;img src=visuels/$fichier.jpg&gt;
				&lt;audio src=audio/$fichier.mp3 controls
				style='width: 100px'&gt;&lt;/audio&gt;&lt;/div&gt;";
	}
}			// Fin de la classe GuitareElectrique
				
htmlDebut('Méthode spécifique dans la classe fille');

$g1 = new GuitareElectrique('Fender Strat', 609, 6, 3, true);
$g1-&gt;decrire();

echo $g1-&gt;getMedias();

$g2 = new GuitareElectrique('Gretsch G5420', 869, 6, 2, true);
$g2-&gt;decrire();

echo $g2-&gt;getMedias();

htmlFin();
?&gt;</textarea>
			</form>
		</section>
		
		<footer></footer>
	</div>
</body>
</html>
