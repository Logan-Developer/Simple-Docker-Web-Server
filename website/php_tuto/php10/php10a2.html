<!DOCTYPE html>
<html>
<head>
<title>Objets : encapsulation, accesseurs et mutateurs</title>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<link rel="stylesheet" href="../_local/codemirror.css">
<script src="../_local/codemirror_pour_php.js"></script>

<link rel="stylesheet" href="../_core/def.css">
<script>
	if (top.FP) {
		document.addEventListener('DOMContentLoaded', top.FP.initPage, false);
	} else {
		location.replace('../index.html?x=' + encodeURI(location.href));
	}
</script>
</head>
<body>
	<div id="MENU-top"></div>
	<nav id="MENU-tuto"></nav>

	<div id="PAGE-tuto">
		<header></header>
		<ul id="MENU-page"></ul>

		<p>
			Un des principes de la programmation objet s'appelle <strong>l'encapsulation</strong>. Il permet
			de garder la cohérence des données stockées dans un objet en restreignant l'accés aux attributs
			et méthodes de cet objet.
		</p>

		<h3>Encapsulation</h3>
		<section>
			<p class="fp-cadre">
				L'encapsulation est réalisée en définissant des <strong>droits d'accès sur les données
					d'un objet</strong>. On donne ainsi plus ou moins de visibilité au monde extérieur sur l'intérieur de
				l'objet. On fait souvent l'analogie avec <strong>une boîte noire</strong>. Par exemple un moteur
				de voiture peut être considéré comme une boîte noire : on n'a pas à connaître son fonctionnement
				détaillé pour pouvoir utiliser la voiture dont il fait partie.
			</p>


			<ul class="fp-cadre" style="margin-bottom: 1em">
				<li><strong>Les attributs ne doivent pas pouvoir être atteints directement</strong>, mais
					uniquement par l'intermédiaire de <strong>méthodes spécialisées</strong> pour l'écriture et la
					lecture de sa valeur.</li>
				<li class="fp-puce">Une méthode spécialisée dans l'écriture de la valeur d'un attribut
					s'appelle un <strong>mutateur</strong> ou <strong>setter</strong> (prononcer setteur).
				</li>
				<li class="fp-puce">Une méthode spécialisée dans la lecture de la valeur d'un attribut
					s'appelle un <strong>accesseur</strong> ou <strong>getter</strong> (prononcer gueteur).
				</li>
			</ul>

			<p class="fp-cadre">Les méthodes ne doivent pouvoir être atteintes directement que si elles
				concernent la "communication" avec le monde extérieure. Si elles concernent le fonctionnement
				interne de l'objet elles doivent être cachées.</p>

			<p class="fp-puce">Le concepteur d'une classe ne doit jamais laisser l'utilisateur d'une
				classe manipuler les objets instanciés sans restriction (même si le concepteur est également
				l'utilisateur). L'utilisateur d'une classe doit se contenter d'utiliser les méthodes mises à sa
				disposition, sans connaître les détails des traitements éventuellement réalisés sur les
				attributs.</p>
			<p class="fp-puce">En n'utilisant un objet qu'à travers ses méthodes, on a la garantie de
				conserver l'objet dans un état cohérent et prévu par le concepteur.</p>
			<p class="fp-puce">Le fait d'accéder aux attributs d'une classe uniquement par des méthodes
				offre également l'avantage de pouvoir modifier ou faire évoluer un objet sans changer son
				comportement extérieur (ie les méthodes à invoquer). Cela permet de séparer la spécification du
				comportement d'un objet de l'implémentation en langage informatique de cette spécification.</p>
		</section>

		<h3>Visibilité</h3>
		<section>
			<p class="fp-puce">
				La visibilité d'un attribut ou d'une méthode définit l'endroit à partir duquel on peut avoir
				accès à cet attribut ou à cette méthode.
				<br>
				Trois mots-clés permettent de définir cette visibilité.
			</p>

			<table>
				<tr>
					<td>Endroit</td>
					<td>Mot-clé</td>
					<td>Remarque</td>
				</tr>

				<tr>
					<td>Uniquement la classe</td>
					<td><code>private</code></td>
					<td>La visibilité <code>private</code> est la plus faible (le droit d'accès le plus
						restreint). Les éléments <code>private</code> ne sont vus que depuis l'intérieur de la classe
						qui les implémente. On ne pourra pas les atteindre depuis un autre endroit du code (autres
						classes, autres endroits du script). <br>En <a
						href="https://fr.wikipedia.org/wiki/UML_%28informatique%29" target="_blank">UML</a> La
						visibilité <code>private</code> est symbolisée par le signe moins (<strong><code>-</code></strong>).
					</td>
				</tr>

				<tr>
					<td>La classe et ses enfants</td>
					<td><code>protected</code></td>
					<td>La visibilité <code>protected</code> est une extension de <code>private</code>. Les
						éléments <code>protected</code> sont vus depuis la classe qui les implémente et depuis les
						classes qui héritent de cette super-classe. Les autres classes et les autres endroits du
						script n'auront pas accès à ses éléments.<br>En <a
						href="https://fr.wikipedia.org/wiki/UML_%28informatique%29" target="_blank">UML</a> La
						visibilité <code>protected</code> est symbolisée par le signe dièse (<strong><code>#</code></strong>).
					</td>
				</tr>
				<tr>
					<td>Partout</td>
					<td><code>public</code></td>
					<td>La visibilité <code>public</code> est celle qui donne le plus de visibilité aux
						élements. Ils sont visible et accessibles de tous les endroits du code. Ce type de visibilité
						brise la règle de l'encapsulation des données.<br>En <a
						href="https://fr.wikipedia.org/wiki/UML_%28informatique%29" target="_blank">UML</a> La
						visibilité <code>public</code> est symbolisée par le signe plus (<strong><code>+</code></strong>).
					</td>
				</tr>
			</table>

			<p class="fp-puce">Les mots-clés de visibilité se placent au début de la définition des
				attributs ou des méthodes.</p>

			<figure>
				<img src="../phpimg/poo_09.png" width="500" height="327">
				<figcaption>définir la visibilité des attributs et des méthodes</figcaption>
			</figure>

			<p class="fp-puce">Quand la visibilité d'un attribut ou d'une méthode est définie, cette
				visibilité ne peut plus être changée dans le code.</p>

			<p class="fp-remarque">
				La visibilité <code>protected</code> sera étudiée quand nous parlerons de <a
					onclick="top.FP.Voir.showPageTuto('php10b1')">l'héritage</a>.
			</p>

			<p>
				L'exemple suivant reprend la classe Guitare et rend <code>public</code> les attributs nombre de
				cordes et taux de remise. La méthode getPrix() est quant à elle passée en <code>private</code>.
				<br>
				Après instanciation d'un objet guitare, on peut donc changer son nombre de cordes de n'importe
				où dans le script. Cette opération est bien évidemment impossible dans le monde réel où par
				exemple un modèle 4 cordes ne peut pas être changé en 12 cordes
				<br>
				On peut également modifier la remise sans contrôle. Ici on donne une valeur négative ce qui a
				pour effet non pas de faire une remise mais de doubler le prix de la guitare.
				<br>
				Finalement, le script s'arrête avec un message d'erreur quand on essaye depuis l'extérieur de la
				classe d'invoquer la méthode <code>private</code> getPrix().
			</p>

			<form action="" method="post" class="TEST-form">
				<a class="TEST-lien" onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_13.html')"
					title="Afficher la bibliothéque de fonctions"></a>
				<div class="TEST-titre">
					<strong>Exemple</strong> : visibilité des attributs et des méthodes
				</div>
				<textarea name="txtCode" class="TEST-textarea" data-wrap>
&lt;?php
ob_start();
require('bib_fonctions.php');

// Définition de la classe Guitare
class Guitare {
	private $modele;
	private $prix;
	public $cordes;
	public $remise = 0;

	public function __construct($p1, $p2, $p3) {
		$this-&gt;modele = $p1;
		$this-&gt;prix = $p2;
		$this-&gt;cordes = $p3;
	}

	private function getPrix() {
		$rem = ceil($this-&gt;prix * $this-&gt;remise / 100);
		return $this-&gt;prix - $rem;
	}

	public function decrire() {
		echo '&lt;h4&gt;Instance de la classe ', __CLASS__, '&lt;/h4&gt;',
				$this-&gt;modele, '&lt;br&gt;', 
				$this-&gt;cordes, ' cordes&lt;br&gt;',
				$this-&gt;getPrix(), ' &amp;euro;';
	}
}			// Fin de la classe Guitare	

htmlDebut('Visibilité attributs et méthodes');

// création d'un nouvel objet instance de la classe Guitare
$guitare = new Guitare('Guild D120', 639, 6);

// Etat normale de l'objet
$guitare-&gt;decrire();

// Ajout d'incohérences dans l'objet
$guitare-&gt;cordes = 36;
$guitare-&gt;remise = -100;

$guitare-&gt;decrire();

// L'appel de cette méthode privée provoque l'arrêt 
// du script avec l'affichage d'une erreur fatale
$guitare-&gt;getPrix();

htmlFin();
?&gt;</textarea>
			</form>
		</section>

		<h3>Accesseurs et mutateurs</h3>
		<section>
			<p class="fp-puce">Pour mettre en place le principe de l'encapsulation (masquer les données),
				mais néanmoins permettre d'en voir et d'en modifier certaines avec ou sans condition de
				validité, on va définir des méthodes spécialisées dans ces traitements.</p>

			<p class="fp-puce">
				Une méthode spécialisée dans la lecture de la valeur d'un attribut s'appelle un <strong>accesseur</strong>
				ou <strong>getter</strong> (prononcer guetteur). Par convention ces méthodes sont préfixées par
				<code>get</code> suivi du nom de l'attribut dont elles renvoient la valeur.
				<br>
				Exemple : <code>getModele()</code>, <code>getRemise()</code>, ou <code>get_modele()</code>, <code>get_remise()</code>,
				etc. suivant votre style de nommage.
			</p>

			<p class="fp-puce">
				Une méthode spécialisée dans l'écriture de la valeur d'un attribut s'appelle un <strong>mutateur</strong>
				ou <strong>setter</strong> (prononcer setteur). Par convention ces méthodes sont préfixées par <code>set</code>
				suivi du nom de l'attribut dont elles modifient la valeur..
				<br>
				Exemple : <code>setModele()</code>, <code>setRemise()</code>,ou <code>set_modele()</code>, <code>set_remise()</code>,
				etc. suivant votre style de nommage.
			</p>

			<p class="fp-puce">
				Généralement les accesseurs et les mutateurs sont des méthodes <code>public</code> puisqu'elles
				sont sensées permettre à l'extérieur d'accèder à des attributs intérieurs (<code>private</code>
				ou <code>protected</code>).
			</p>

			<p class="fp-puce">Tous les attributs ne doivent pas forcément avoir des getters et/ou des
				setters. Seuls les attributs exposés au monde extérieur en ont besoin.</p>

			<form action="" method="post" class="TEST-form">
				<a class="TEST-lien" onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_13.html')"
					title="Afficher la bibliothéque de fonctions"></a>
				<div class="TEST-titre">
					<strong>Exemple</strong> : la classe guitare avec accesseurs et mutateurs
				</div>
				<textarea name="txtCode" class="TEST-textarea" data-wrap>
&lt;?php
ob_start();
require('bib_fonctions.php');

class Guitare {
	private $modele, $prix, $cordes, $remise = 0;

	// Constructeur
	public function __construct($p1, $p2, $p3) {
		$this-&gt;modele = $p1;
		$this-&gt;prix = $p2;
		$this-&gt;cordes = $p3;
	}	
	// Getter de l'attribut remise
	public function getRemise() {
		return $this-&gt;remise();
	}	
	// Le setter de l'attribut remise vérifie que la remise
	// est une valeur numérique comprise entre 0 et 100
	public function setRemise($taux) {
		if (is_numeric($taux) &amp;&amp; estEntre($taux, 0, 100)) {
			$this-&gt;remise = $taux;
		}
	}	
	// Il n'y a pas de setter pour le prix. Une fois l'objet 
	// instancié, on ne peut plus modifier son prix.
	// Le getter du prix ne renvoie pas simplement
	// le prix de base, mais le prix remise déduite.
	public function getPrix() {
		$rem = ceil($this-&gt;prix * $this-&gt;remise / 100);
		return $this-&gt;prix - $rem;
	}

	public function decrire() {
		echo '&lt;h4&gt;Instance de la classe ', __CLASS__, '&lt;/h4&gt;',
				$this-&gt;modele, '&lt;br&gt;', 
				$this-&gt;cordes, ' cordes&lt;br&gt;',
				$this-&gt;getPrix(), ' &amp;euro;';	
	}
}			// Fin de la classe Guitare	

htmlDebut('La classe Guitare avec getters et setters');

$guitare = new Guitare('Fender Villager', 444, 12);
$guitare-&gt;decrire();

// Invocation du setter du taux de remise
$guitare-&gt;setRemise(30);
// Invocation du getter du prix
htmlInfo('Prix avec remise : '.$guitare-&gt;getPrix());

// Invocation du setter setRemise avec une mauvaise valeur
$guitare-&gt;setRemise(-100);
// La mauvaise remise n'est pas prise en compte
htmlInfo('Prix avec remise : '.$guitare-&gt;getPrix());

// Essayer de modifier la valeur d'un attribut privé
// provoque une erreur fatale et l'arrêt du script
$guitare->cordes = 123;

htmlFin();
?&gt;</textarea>
			</form>
		</section>

		<a id="exoGetSet"></a>
		<h3 class="fp-exo">Exercice : getter et setter</h3>
		<section>
			<figure style="float: right; margin: 0 0 0 15px;">
				<img src="../phpimg/poo_30.png" width="130" height="216">
				<figcaption>la classe Livre</figcaption>
			</figure>
			<p>
				Reprenez la classe <code>Livre</code> de <a
					onclick="top.FP.Voir.showPageTuto('php10a1','exoClasseLivre')">l'exercice précédent</a> et écrivez les setters pour tous
				les attributs.
				<br>
				Les attributs <code>titre</code> et <code>auteur</code> ne doivent pas être vides.
				<br>
				L'attribut <code>pages</code> doit être un nombre entre 10 et 1000.
				<br>
				L'attribut <code>prix</code> doit être un nombre entre 0 et 1000.
				<br>
				L'attribut <code>cat</code> doit être "Méthode", "Partition", "Biographie" ou "Autre".
			</p>

			<p>
				Si les valeurs passées aux setters ne sont pas valides, l'attribut n'est pas modifié et un
				message d'erreur doit être affiché et le script continue son éxécution sans s'arrêter.
				<br>
				Le message d'erreur affiché doit être de la forme 'Valeur [valeur passée] invalide pour
				l'attribut [nom attribut].'</p>
				
			<p>Pour tester, une instances de la classe <code>Livre</code> doit être créée de la façon suivante :
				<br>
				<code>$livre = new Livre('Débutant Guitare Acoustique', 'Rébillard', 70, 17, 'Méthode');</code><br>
				Voud devez ensuite invoquer chacun des setters une valeur invalide puis une valeur valide pour vérifier que votre 
				traitement est correct.
			</p>

			<figure>
				<img src="../phpimg/poo_31.png" width="520" height="422">
				<figcaption>affichage obtenu</figcaption>
			</figure>
			<p class="fp-solution">
				<a onclick="top.FP.Voir.showSolution('exoGetSet_solu', 1)">Une solution possible</a>
			</p>

			<div id="exoGetSet_solu" class="BLOC-solution">
				<form action="" method="post" class="TEST-form">
					<a class="TEST-lien" onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_13.html')"
						title="Afficher la bibliothéque de fonctions"></a>
					<div class="TEST-titre">
						<strong>Exercice</strong> : getters et setters
					</div>
					<textarea name="txtCode" class="TEST-textarea" data-wrap>
&lt;?php
ob_start();
require('bib_fonctions.php');

// Définition de la classe Livre
class Livre {
	private $titre, $auteur, $pages, $prix, $cat;

	public function __construct($p1, $p2, $p3, $p4, $p5) {
		$this-&gt;titre = $p1;
		$this-&gt;auteur = $p2;
		$this-&gt;pages = $p3;
		$this-&gt;prix = $p4;
		$this-&gt;cat = $p5;
	}
	public function setTitre($val) {
		$val = $this-&gt;verifChaine($val, 'titre');
		($val != '') &amp;&amp; $this-&gt;titre = $val;
	}
	public function setAuteur($val) {
		$val = $this-&gt;verifChaine($val, 'auteur');
		($val != '') &amp;&amp; $this-&gt;auteur = $val;
	}
	public function setPages($val) {
		if (is_numeric($val) &amp;&amp; estEntre($val, 10, 1000)) {
			$this-&gt;pages = $val;
		} else {
			$this-&gt;afficheErreur($val, 'pages');
		}
	}
	public function setPrix($val) {
		if (is_numeric($val) &amp;&amp; estEntre($val, 0, 1000)) {
			$this-&gt;prix = $val;
		} else {
			$this-&gt;afficheErreur($val, 'prix');
		}
	}
	public function setCat($val) {
		$oks = array('Méthode', 'Partition', 
					 'Biographie', 'Autre');
		if (in_array($val, $oks)) {
			$this-&gt;cat = $val;
		} else {
			$this-&gt;afficheErreur($val, 'cat');
		}
	}
	private function verifChaine($val, $attr) {
		$val = trim($val);
		($val == '') &amp;&amp; $this-&gt;afficheErreur($val, $attr);
		return $val;
	}
	private function afficheErreur($val, $attr) {
		echo "&lt;hr&gt;Valeur '&lt;b&gt;$val&lt;/b&gt;' invalide pour
			l'attribut &lt;b&gt;$attr&lt;/b&gt;.&lt;hr&gt;";
	}
	public function decrire() {
		echo '&lt;h4&gt;Instance de la classe Livre&lt;/h4&gt;',
				$this-&gt;titre, ' - ', $this-&gt;auteur, ' - ', 
				$this-&gt;pages, ' pages - ', 
				$this-&gt;prix, ' &amp;euro; - ', $this-&gt;cat, '&lt;hr&gt;';
	}
}			// Fin de la classe Livre

htmlDebut('Getters et setters');

$livre = new Livre('Débutant Guitare Acoustique', 'Rébillard', 70, 17, 'Méthode');

$livre-&gt;decrire();

$livre-&gt;setTitre('  ');
$livre-&gt;setTitre('Guitar Play Along Neil Young');

$livre-&gt;setAuteur('');
$livre-&gt;setAuteur('Leonard');

$livre-&gt;setPages(1);
$livre-&gt;setPages(50);

$livre-&gt;setPrix('30 euros');
$livre-&gt;setPrix(30);

$livre-&gt;setCat('Rock');
$livre-&gt;setCat('Partition');

$livre-&gt;decrire();

htmlFin();
?&gt;</textarea>
				</form>
			</div>
		</section>

		<h3>Getters et setters magiques</h3>
		<section>

			<div class="fp-f-right">
				<img src="../phpimg/harrypotter.png" width="150" height="214">
			</div>

			<p class="fp-puce">Parfois, quand les attributs d'une classe sont nombreux, il peut être
				pénible d'écrire des getters et des setters dont la plupart n'auront qu'une ligne de code.</p>

			<p class="fp-puce">
				Pour nous faciliter la tâche, PHP met à notre disposition ce qu'on appelle des "méthodes
				magiques". Deux d'entre elles vont dans notre cas être bien utiles : la méthode magique <code>__get()</code>
				et la méthode magique <code>__set()</code>.
			</p>

			<p class="fp-puce">
				Comme leur nom l'indique, <code>__get()</code> est un getter et <code>__set()</code> est un
				setter.
				<br>
				<code>__get()</code> accepte en paramètre le nom de l'attribut pour lequel on veut connaître la
				valeur.
				<br>
				<code>__set()</code> accepte 2 paramètres : le nom de l'attribut pour lequel on veut modifier la
				valeur et la nouvelle valeur à affecter à l'attribut.
			</p>

			<p class="fp-puce">
				<code>__get()</code> et <code>__set()</code>sont invoqué automatiquement par PHP quand le monde
				extérieur essaye d'accéder à un attribut dont l'accés lui est refusé.
				<br>
				Le refus d'accès peut avoir 2 causes :
				<br>
				- l'attribut est <code>private</code> ou <code>protected</code>,
				<br>
				- l'attribut n'est pas défini dans la classe.
			</p>

			<p class="fp-puce">Dans le code de ces 2 méthodes, nous définissons ce qui est fait dans le
				cas ou l'attribut n'est pas défini et ce qui est fait si l'attribut est défini : renvoi ou pas
				d'une valeur, modification ou pas d'une valeur</p>

			<p class="fp-remarque">
				Les méthodes magiques dans PHP commencent toutes par un double underscore <code>__</code> suivi
				du nom de la méthode.
			</p>


			<p class="fp-puce">Tous les attributs ne doivent pas forcément avoir des getters et/ou des
				setters. Seuls les attributs exposés au monde extérieur en ont besoin.</p>

			<form action="" method="post" class="TEST-form">
				<a class="TEST-lien" onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_13.html')"
					title="Afficher la bibliothéque de fonctions"></a>

				<div class="TEST-titre">
					<strong>Exemple</strong> : méthode magique __get()
				</div>
				<textarea name="txtCode" class="TEST-textarea" data-wrap>
&lt;?php
ob_start();
require('bib_fonctions.php');

class Guitare {
	private $modele, $prix, $cordes, $remise = 0;

	// Constructeur
	public function __construct($p1, $p2, $p3) {
		$this-&gt;modele = $p1;
		$this-&gt;prix = $p2;
		$this-&gt;cordes = $p3;
	}	
	public function getPrix() {
		$rem = ceil($this-&gt;prix * $this-&gt;remise / 100);
		return $this-&gt;prix - $rem;
	}

	// méthode magique __get()	
	public function __get($nom_attribut) {
		if (!isset($this-&gt;$nom_attribut)) {
			exit("Erreur : attribut $nom_attribut indéfini.");
		}
		// L'attribut prix n'est jamais accessible directement
		// car la valeur retrounée est toujours le résultat
		// d'un calcul avec la remise.
		if ($nom_attribut == 'prix') {
			return $this-&gt;getPrix();
		}
		// Tous les autres attributs renvoient leur valeur
		// Remarquez ici le $ après -&gt;
		// On atteint un attribut ou une méthode, soit 
		// directement avec leur nom, soit indirectement 
		// avec une variable. Dans ce cas pour indiquer qu'on 
		// utilise une variable on a la syntaxe avec $
		return $this-&gt;$nom_attribut;
	}
}			// Fin de la classe Guitare	

htmlDebut('La méthode magique __get()');

$guitare = new Guitare('Fender Villager', 444, 12);
htmlInfo('Modèle : '.$guitare-&gt;modele);
htmlInfo('Nombre de corde : '.$guitare-&gt;cordes);
htmlInfo('Taux de remise : '.$guitare-&gt;remise.'%');
htmlInfo('Prix : '.$guitare-&gt;prix.' euros');

// Provoque l'arrêt du script
htmlinfo('Attribut indéfini : '.$guitare-&gt;stock);
htmlFin();
?&gt;</textarea>
			</form>

			<p class="fp-puce">
				La méthode magique <code>__set()</code> fonctionne comme <code>__get()</code> à la différence
				qu'elle permet au monde extérieur de modifier la valeur d'un attribut. A mon avis l'utilisation
				de <code>__set()</code> est à éviter car il faut toujours vérifier les valeurs des attributs
				pour que l'état de l'objet reste cohérent. Comme on l'a vu précédemment, permet de modifier la
				valeur de l'attribut <code>remise</code> sans contrôle permet d'introduire des erreurs dans le
				traitement du prix de vente d'un livre.
			</p>

			<p>
				L'exemple suivant montre l'utilisation de <code>__set()</code>. Encore une fois, je pense qu'il
				faut mieux ne pas utiliser cette méthode dans les développements car on perd les contrôles que
				l'on peut faire sur les valeurs des attributs, ou ses contrôles s'ils sont faits dans <code>__set()</code>
				donneront souvent un code difficile à maintenir.
			</p>

			<form action="" method="post" class="TEST-form">
				<a class="TEST-lien" onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_13.html')"
					title="Afficher la bibliothéque de fonctions"></a>

				<div class="TEST-titre">
					<strong>Exemple</strong> : méthode magique __set()
				</div>
				<textarea name="txtCode" class="TEST-textarea" data-wrap>
&lt;?php
ob_start();
require('bib_fonctions.php');

class Guitare {
	private $modele, $prix, $cordes, $remise = 0;

	// Constructeur
	public function __construct($p1, $p2, $p3) {
		$this-&gt;modele = $p1;
		$this-&gt;prix = $p2;
		$this-&gt;cordes = $p3;
	}
	// méthode magique __set()	
	public function __set($nom_attribut, $val) {
		switch ($nom_attribut) {
		case 'prix':
			if (!is_numeric($val)) return;
			if ($val &lt;= 0) return;
			break;
			
		case 'remise':
			if (!is_numeric($val)) return;
			if (!estEntre($val, 0, 100)) return;
			break;
			
		case 'cordes':
			return;	// pas modifiable
			
		case 'modele':
			$val = trim($val);
			if ($val == '') return;
			break;
			
		default: 
			exit("Erreur : attribut $nom_attribut indéfini.");
		}
		
		$this-&gt;$nom_attribut = $val;
	}
	public function getPrix() {
		$rem = ceil($this-&gt;prix * $this-&gt;remise / 100);
		return $this-&gt;prix - $rem;
	}

	// méthode magique __get()	
	public function __get($nom_attribut) {
		if (!isset($this-&gt;$nom_attribut)) {
			exit("Erreur : attribut $nom_attribut indéfini.");
		}
		return ($nom_attribut == 'prix') 
				? $this-&gt;getPrix() 
				: $this-&gt;$nom_attribut;
	}
}			// Fin de la classe Guitare	

htmlDebut('La méthode magique __set()');

$guitare = new Guitare('Fender Villager', 444, 12);

$guitare->modele = 'François Piat';
$guitare->cordes = 1234;
$guitare->prix = 10;
$guitare->remise = 'cent pour cent';

htmlInfo('Modèle : '.$guitare-&gt;modele);
htmlInfo('Nombre de corde : '.$guitare-&gt;cordes);
htmlInfo('Taux de remise : '.$guitare-&gt;remise.'%');
htmlInfo('Prix : '.$guitare-&gt;prix.' euros');

// Provoque l'arrêt du script
$guitare-&gt;stock = 2;

htmlFin();
?&gt;</textarea>
			</form>

		</section>
		<footer></footer>
	</div>
</body>
</html>
