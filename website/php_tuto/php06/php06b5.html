<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>Urls - liens</title>
<link rel="stylesheet" href="../_local/codemirror.css">
<script src="../_local/codemirror_pour_php.js"></script>

<link rel="stylesheet" href="../_core/def.css">
<script>
	if (top.FP) {
		document.addEventListener('DOMContentLoaded', top.FP.initPage, false);
	} else {
		location.replace('../index.html?x=' + encodeURI(location.href));
	}
</script>
</head>
<body>
	<div id="MENU-top"></div>
	<nav id="MENU-tuto"></nav>

	<div id="PAGE-tuto">
		<header></header>
		<ul id="MENU-page"></ul>

		<p>
			Nous avons vu que le navigateur utilise 2 méthodes privilégiées pour
			faire une requête au serveur : <span class="fp-code">POST</span> et <span
				class="fp-code">GET</span>. Ces 2 méthodes permettent de passer des
			informations au serveur, soit dans le corps du message HTTP (<span
				class="fp-code">POST</span>), soit à la suite de l'url demandée (<span
				class="fp-code">GET</span>). Nous allons voir ici plus en détail le
			passage d'informations par url et leur récupèration dans le tableau <a
				href="https://www.php.net/manual/fr/reserved.variables.get.php" target="_blank">$_GET</a>.
		</p>

		<h3>Passer des paramètres dans un lien</h3>
		<section>
			<h4>Principes</h4>
			<section>
				<p class="fp-puce">Une url est composée des parties suivantes :</p>
				<figure>
					<img src="../phpimg/url.png" width="590" height="86">
					<figcaption>composition d'une URL</figcaption>
				</figure>


				<p class="fp-puce">
					C'est la partie "query string" qui nous intéresse. Les informations
					sont passées sous la forme de couples nom=valeur, séparés par le
					caractère &amp;. Sur le serveur, avec PHP, on retrouve ces couples
					dans le tableau <a
						href="https://www.php.net/manual/fr/reserved.variables.get.php" target="_blank">$_GET</a>
					: le nom devient une clé et la valeur est la valeur associée à
					cette clé.
				</p>

				<p>
					Exemple de lien :<br> <span class="fp-code">&lt;a
						href="lien01_get.php?id=12345&amp;nom=piat"
						target="_blank"&gt;cliquez ici&lt;/a&gt;</span><br> Rendu :<br>
					<a href="lien01_get.php?id=12345&nom=piat" target="_blank">cliquez
						ici</a>
				</p>
				<p class="fp-remarque">L'attribut target permet de spécifier la
					cible dans laquelle va s'afficher le lien (ici un nouvel onglet
					pour qu'on puisse voir l'url dans la barre d'url du navigateur)</p>

				<p>
					Le code PHP du fichier <span class="fp-code">lien01_get.php</span>
					est le suivant :
				</p>
				<pre data-code="PHP">
&lt;?php
require('bib_fonctions.php');

htmlDebut('Informations transmises dans une url');

foreach ($_GET as $nom =&gt; $valeur) {
	htmlInfo($nom);
	echo $valeur;
}

htmlFin();
?&gt;</pre>
			</section>
			<h4>Protection des chaînes</h4>
			<section>

				<p class="fp-puce fp-bottom0">Si les valeurs des paramètres
					passés dans l'url sont des chaînes de caractères, elles doivent
					être protégées car les urls ont un codage spécifiques pour certains
					caractères (caractères de séparations, caractères accentués, etc).
					On utilise :</p>
				<ul class="fp-ul-puce">
					<li><a
						href="https://www.php.net/manual/fr/function.urlencode.php" target="_blank">urlencode()</a>
						du côté de l'émetteur, pour protéger la chaîne avant de la placer
						dans l'url,</li>
					<li>du côté du récepteur, on n'a pas besoin de décoder la
						chaîne pour retrouver la chaîne originale car PHP le fait
						automatiquement pour tout ce qu'il stocke dans <a
						href="https://www.php.net/manual/fr/reserved.variables.get.php" target="_blank">$_GET</a>.
					</li>
				</ul>

				<form action="" method="post" class="TEST-form">
					<a class="TEST-lien"
						onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_06.html')"
						title="Afficher la bibliothéque de fonctions"></a>
					<div class="TEST-titre">
						<strong>Exemple</strong> : paramètres dans des liens
					</div>
					<textarea name="txtCode" class="TEST-textarea">
&lt;?php
require('bib_fonctions.php');

htmlDebut('Paramètres dans des liens');

if (isset($_GET['x'])) {
	htmlInfo('Réception x - pas besoin de décodage');
	echo $_GET['x'];
	htmlInfo('Réception y - pas besoin de décodage');
	echo $_GET['y'];
	htmlInfo('Réception z');
	echo $_GET['z'], 
	     '&lt;hr&gt; DEBUG : ', 
		 gettype($_GET['z']); // piqure de rappel
	htmlFin();
	exit();
}

htmlInfo('Emission');
$lien = $_SERVER['PHP_SELF'];
$lien .= '?x='.urlencode('François Piat');
$lien .= '&y='.urlencode('5=4+1');
$lien .= '&z=12345'; // pas besoin d'encodage

echo '&lt;a href="', $lien, '" target="_blank"&gt;Cliquez ici&lt;/a&gt;';

htmlFin();
?&gt;</textarea>
				</form>
			</section>
			
			<h4>Dangers</h4>
			<section>
				<p class="fp-remarque">Le lien de l'exemple s'ouvrira dans un
					nouvel onglet pour que vous puissiez voir/manipuler l'url.</p>
				<p class="fp-remarque">Remarquez l'encodage réalisé par <a
						href="https://www.php.net/manual/fr/function.urlencode.php" target="_blank">urlencode()</a> :<br>
					- le caractère <span class="fp-code">ç</span> (codé avec le charset ISO-8859-1) est remplacé par 
					<span class="fp-code">%E7</span><br>
					- le caractère <span class="fp-code">=</span> est remplacé par <span class="fp-code">%3D</span><br>
					- le caractère espace (<span class="fp-code">&nbsp;</span>) est remplacé par un <span class="fp-code">+</span><br>
					- les caractères alphanumériques ne sont pas modifiés
				</p>

				<p class="fp-puce">On utilise fréquemment les paramètres dans
					les urls pour passer des informations de page en page bien que
					l'une des faiblesses viennnent de la modification manuelle possible
					de l'url affichée par le navigateur.</p>
				<p class="fp-puce fp-bottom0">
					On peut ainsi facilement passer des informations qui n'étaient pas
					attendues.</p>
				<ul class="fp-ul-puce">
				<li>
					Modifiez par exemple mon nom puis validez. Le script est
					exécuté à nouveau, et la valeur modifiée du nom est affichée.</li>
				<li>On peut de la même façon modifier le nom d'un couple nom=valeur ou en ajouter
				   un et redemander la page.</li>
				</ul>				
					
				<p class="fp-bottom0 fp-puce">Le passage d'informations par les
					urls doit donc être entouré de beaucoup de précautions :</p>
				<ul class="fp-ul-puce">
					<li>si le nombre de couples nom=valeur est différent de celui
						attendu, le script doit être arrêté et tous les éléments
						éventuellement rattachés à l'utilisateur (session par exemple)
						doivent être supprimés,</li>
					<li>les noms des couples reçus doivent être validés,
					<li>les valeurs des couples reçues doivent être validées.
				</ul>
				<p class="fp-puce">
				En l'état actuel, lors de la réception des données, il faudrait, dans ce script, protéger
				les chaînes provenant de la "query string" qui sont envoyées au navigateur avec la fonction <a
					href="https://www.php.net/manual/fr/function.htmlentities.php" target="_blank">htmlentities()</a>
				</p>
			</section>
		</section>

		<h3>Cryptage des paramètres</h3>
		<section>
			<p class="fp-puce">Le cryptage et la signature des données permettent de <b>cacher</b> et de
				<b>protéger</b> les valeurs passées dans les urls.</p>
			<p class="fp-bottom0 fp-puce">
				Le cryptage de données n'est pas la même chose que la signature de
				données (faite avec par exemple la méthode <a
					href="https://www.php.net/manual/fr/function.md5.php" target="_blank">md5</a>
				bien connue) :
			</p>
			<ul class="fp-ul-puce">
				<li>le cryptage applique un algorithme de transformation sur
					une chaîne de caractères en utilisant une clé de cryptage et donne
					en résultat la chaîne cryptée. Celle-ci peut ensuite être décryptée
					(on retrouve la chaîne originale) si on connaît la clé et
					l'algorithme utilisés.</li>
				<li>la signature de données applique un algorithme sur une chaîne de caractères 
				et donne en résultat une autre chaîne de caractères, appelée aussi hash ou empreinte 
				de la chaîne originale. Cette dernière, en général, ne permet pas de retrouver la chaîne 
				originale, mais permettra de vérifier qu'elle n'a pas été altérée. 
				La signature de données permet, par exemple, de vérifier un mot de passe, 
				ou dans le cas d'une transmission de données de vérifier que la chaîne reçue correspond 
				bien à la chaîne émise.
				</li>
			</ul>

			<p class="fp-remarque">La cryptographie et l'étude des différents
				modes de cryptage dépassent de loin le cadre de ce tutoriel et nous
				n'entrerons pas dans les détails de tel ou tel algorithme.</p>

			<h4>Crypter / décrypter</h4>
			<section>
				<p class="fp-puce">
					Pour réaliser des cryptages selon différentes méthodes et
					algorithmes, nous allons utiliser l'extension <a
						href="https://www.php.net/manual/fr/ref.openssl.php" target="_blank">openSSL</a>
					de PHP qui définit la fonction <a
						href="https://www.php.net/manual/fr/function.openssl-encrypt.php" target="_blank">openssl_encrypt()</a>
					et son pendant <a
						href="https://www.php.net/manual/fr/function.openssl-decrypt.php" target="_blank">openssl_decrypt()</a>.
					
					
					Généralement cette extension est compilée avec PHP,
					mais on peut s'en assurer avec la fonction <a
						href="https://www.php.net/manual/fr/function.function-exists.php" target="_blank">function_exists()</a>
					très pratique pour savoir ce qui est disponible dans la
					configuration ou version de PHP.
				</p>

				<form action="" method="post" class="TEST-form">
					<a class="TEST-lien"
						onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_06.html')"
						title="Afficher la bibliothéque de fonctions"></a>
					<div class="TEST-titre">
						<strong>Exemple</strong> : vérification existence des fonctions de cryptage
					</div>
					<textarea name="txtCode" class="TEST-textarea">
&lt;?php
require('bib_fonctions.php');

htmlDebut('Vérifier l\'existence d\'une fonction');

htmlInfo('Fonction openssl_encrypt');
if (function_exists('openssl_encrypt')) {
	echo 'utilisable';
} else {
	echo 'pas dans cette version PHP';
}

htmlInfo('Fonction htmlFin');
echo (function_exists('htmlFin')) ? 'utilisable' : 'ko';

htmlInfo('Fonction francois_piat');
echo (function_exists('francois_piat')) ? 'ok' : 'ko';

htmlFin();
?&gt;</textarea>
				</form>



				<p class="fp-puce">
					Pour crypter/décrypter des données on peut donc utiliser ces fonctions
					<a
						href="https://www.php.net/manual/fr/function.openssl-encrypt.php" target="_blank">openssl_encrypt()</a>
					et <a
						href="https://www.php.net/manual/fr/function.openssl-decrypt.php" target="_blank">openssl_decrypt()</a>
					comme dans l'exemple suivant qui utilise l'algorithme AES (Advanced Encryption Standard) en mode CBC.
				</p>

				<form action="" method="post" class="TEST-form">
					<a class="TEST-lien"
						onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_06.html')"
						title="Afficher la bibliothéque de fonctions"></a>
					<div class="TEST-titre">
						<strong>Exemple</strong> : cryptage / décryptage
					</div>
					<textarea name="txtCode" class="TEST-textarea">
&lt;?php
require('bib_fonctions.php');

htmlDebut('Crypter / décrypter');

htmlInfo('Clé de cryptage');
$cle = 'May the force be with you';
echo $cle;

htmlInfo('Chaîne à crypter');
$val = 'François Piat';
echo $val;

//-- algorithme de cryptage
$cipher='AES-128-CBC';

// -- longueur du vecteur d'initialisation
$ivlen = openssl_cipher_iv_length($cipher);

// -- génération du vecteur d'initialisation
$iv = openssl_random_pseudo_bytes($ivlen);

htmlInfo('Vecteur d\'initialisation');
echo $iv;

// -- cryptage de $val
$x = openssl_encrypt($val, $cipher, $cle, 
                     OPENSSL_RAW_DATA, $iv);
					 
htmlInfo('Chaîne cryptée');
echo $x;

// -- décryptage
$y = openssl_decrypt($x, $cipher, $cle, 
                     OPENSSL_RAW_DATA, $iv);
					 
htmlInfo('Chaîne décryptée');
echo $y;

htmlFin();
?&gt;</textarea>
				</form>
				<p class="fp-puce fp-bottom0">
					Remarques :
				</p>
				<ul class="fp-ul-puce">
				<li>
				Pour crypter <span class="fp-code">$val</span>, la fonction <a
						href="https://www.php.net/manual/fr/function.openssl-encrypt.php" target="_blank">openssl_encrypt()</a>
				utilise un algorithme (le paramètre <span class="fp-code">$cipher</span>), une clé de cryptage <span class="fp-code">$cle</span>, 
				et un vecteur d'initialisation nommé <span class="fp-code">$iv</span>,
				c'est à dire une chaîne pseudo-aléatoire d'octets, dont la longueur
				<span class="fp-code">$ivlen</span> dépend de l'algorithme utilisé.
				</li>
				<li>
					Avec l'option <span class="fp-code">OPENSSL_RAW_DATA</span>, la fonction <a
						href="https://www.php.net/manual/fr/function.openssl-encrypt.php" target="_blank">openssl_encrypt()</a>
						renvoie une chaîne cryptée binaire; cela signifie qu'elle contient des octets qui peuvent prendre n'importe quelle
						valeur.
				</li>
				<li>
					Pour retrouver la chaîne originale, la fonction <a
						href="https://www.php.net/manual/fr/function.openssl-decrypt.php" target="_blank">openssl_decrypt()</a>
					a besoin de l'algorithme utilisé, de la chaîne cryptée, de la clé et du 
					<b>vecteur d'initialisation</b>.
				</li>
				<li>
					A chaque fois qu'on crypte une nouvelle donnée, il faut générer un nouveau vecteur d'initialisation.
				</li>
				<li>
					Dans une "vraie" application Web, il ne faut pas envoyer directement au navigateur une chaîne binaire pouvant 
					contenir n'importe quel octet. Si vous testez le code HTML généré avec le <a
					href="https://validator.w3.org/" target="_blank">validateur W3C</a>, il y détectera des caractères interdits.
					De même, la chaîne binaire pourrait contenir des caractères '&lt;' et '&gt;' ayant une signification particulière en HTML.
					Nous le faisons ici uniquement dans un but pédagogique.
				</li>
				<li>
					Le nombre <span class="fp-code">128</span> dans le nom de l'algorithme de cryptage 
					<span class="fp-code">AES-128-CBC</span> indique la longueur de la clé de cryptage en nombre de bits qu'il
					faut utiliser avec cet algorithme :<br>
					- 128 bits = 16 * 8 bits = 16 octets<br>
					- si on utilise une clé plus longue, elle sera tronquée et seuls les 128 premiers bits seront utilisés pour crypter 
					les données.
				</li>
				</ul>
				
				<p class="fp-puce">Pour générer une clé de cryptage "correcte" à utiliser avec l'algorithme  
				<span class="fp-code">AES-128-CBC</span>, on peut utiliser le script suivant :</p>

				<form action="" method="post" class="TEST-form">
					<a class="TEST-lien"
						onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_06.html')"
						title="Afficher la bibliothéque de fonctions"></a>
					<div class="TEST-titre">
						<strong>Exemple</strong> : génération d'une clé de cryptage
					</div>
					<textarea name="txtCode" class="TEST-textarea">
&lt;?php
require('bib_fonctions.php');

htmlDebut('Génération d\'une clé de cryptage');

htmlInfo('Clé encodée en Base64');
echo base64_encode(openssl_random_pseudo_bytes(16));

htmlFin();
?&gt;</textarea>
</form>
		<p class="fp-remarque">
			La fonction <a
						href="https://www.php.net/manual/fr/function.openssl-random-pseudo-bytes.php" target="_blank">openssl_random_pseudo_bytes()</a>
			renvoie une chaine binaire qu'il ne faut donc pas afficher telle quelle dans le navigateur. La fonction <a
						href="https://www.php.net/manual/fr/function.base64-encode.php" target="_blank">base64_encode()</a>
			permet d'encoder cette chaine binaire en <a href="https://fr.wikipedia.org/wiki/Base64" target="_blank">
			Base64</a>, ce qui permet d'obtenir une chaîne ASCII qui la représente, 
			qu'on peut envoyer sans problème au navigateur pour pouvoir la copier/coller dans le script qui suit.
		</p>



				<p class="fp-puce">Ré-écriture de l'exemple sur le passage de paramètres
					dans une url :</p>

				<form action="" method="post" class="TEST-form">
					<a class="TEST-lien"
						onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_06.html')"
						title="Afficher la bibliothéque de fonctions"></a>
					<div class="TEST-titre">
						<strong>Exemple</strong> : paramètres cryptés dans des liens
					</div>
					<textarea name="txtCode" class="TEST-textarea">
&lt;?php
require('bib_fonctions.php');

//clé générée avec le script précédent
define('CLE_CRYPTAGE', 'ocKSOzNlBxCu1hsziDoUCQ==');

htmlDebut('Paramètres cryptés dans des liens');

if (count($_GET)&gt; 0) {
	afficherReception();
	exit();
}

htmlInfo('Emission');

$x = crypteURL('François Piat');

$lien = $_SERVER['PHP_SELF'];
$lien .= "?x=$x";
$lien .= '&y='.crypteURL('bonjour les étudiants');
$lien .= '&z='.crypteURL(12345);

echo '&lt;hr&gt; DEBUG : strlen($x) = ', strlen($x) ,'&lt;hr&gt;';

echo '&lt;a href="', $lien, '" target="_blank"&gt;Cliquez ici&lt;/a&gt;';

htmlFin();

/**
 * Affichage des données reçues.
 * 
 * Contrôle de la validité :
 * - du nombre de couple nom=valeur reçus
 * - des noms de ces couples
 */
function afficherReception() {
	if (count($_GET) != 3){
		echo 'Tentative de piratage ?';
		htmlFin();
		return;
	}
	$t = array('x', 'y', 'z');
	foreach($_GET as $cle =&gt; $val){
		if (!in_array($cle, $t)){
			echo 'Tentative de piratage ?';
			htmlFin();
			return;
		}
		htmlInfo("Réception $cle");
		echo decrypteURL($val);
	}
	htmlFin();
}

/**
 * Crypte une valeur pour la passer dans une URL.
 *
 * @param mixed		$val	La valeur à crypter
 * @return string	La valeur cryptée encodée url
 */
function crypteURL($val){
	$cle = base64_decode(CLE_CRYPTAGE);
	// -- longueur du vecteur d'initialisation
	$ivlen = openssl_cipher_iv_length($cipher='AES-128-CBC');
	// -- génération du vecteur d'initialisation
	$iv = openssl_random_pseudo_bytes($ivlen);
	// -- cryptage de $val
	$x = openssl_encrypt($val, $cipher, $cle, 
	                     OPENSSL_RAW_DATA, $iv);
	$x = $iv.$x;
	echo '&lt;hr&gt; DEBUG : ', strlen($x);
	//$x = base64_encode($x); 
	return urlencode($x);
}

/**
 * Décrypte une valeur cryptée avec la fonction crypteURL()
 *
 * @param string	$x	La valeur à décrypter
 * @return string	La valeur décryptée
 */
function decrypteURL($x){
	$cle = base64_decode(CLE_CRYPTAGE);
	$ivlen = openssl_cipher_iv_length($cipher='AES-128-CBC');
	//$x = base64_decode($x);
	return openssl_decrypt(substr($x, $ivlen), $cipher, 
	                       $cle, OPENSSL_RAW_DATA, 
						   substr($x, 0, $ivlen));
}
?&gt;</textarea>
				</form>
				<p class="fp-remarque">Le lien de l'exemple s'ouvrira dans un
					nouvel onglet pour que vous puissiez voir/manipuler l'url.</p>
				<p class="fp-remarque">
					La longueur de la chaîne cryptée n'est pas constante.
				</p>
				<p class="fp-puce fp-inter2 fp-bottom0">
					La clé de cryptage est définie par une constante. Par conséquent, pour être capable de décrypter 
					la chaîne cryptée à la réception des paramètres, il faut transmettre dans l'url la chaîne cryptée (retournée
					par <a
						href="https://www.php.net/manual/fr/function.openssl-encrypt.php" target="_blank">openssl_encrypt()</a>) et
					le vecteur d'initialisation <span class="fp-code">$iv</span>. Comme le vecteur d'initialisation <span class="fp-code">$iv</span>
					a toujours la même longueur, nous pouvons les concaténer : on sera capable de séparer les 2 chaines lors de la
					réception.
					Ces 2 chaînes sont des chaînes binaires. Il est
					donc absolument nécessaire de les encoder avec <a
						href="https://www.php.net/manual/fr/function.urlencode.php" target="_blank">urlencode()</a>
					si on veut les passer dans une url.</p>
				<p class="fp-puce fp-bottom0">
					La fonction <a
						href="https://www.php.net/manual/fr/function.urlencode.php" target="_blank">urlencode()</a>
					remplace tous les caractères non alphanumériques (hormis -_.) par des séquences commençant par un caractère 
					pourcentage (%), suivi de deux chiffres hexadécimaux. Les espaces sont remplacés par des signes plus (+).
					Cela signifie que tous les octets qui ne sont pas
					des codes ASCII des caractères alphanumériques, ou du caractère (-), ou du caractère (_), ou du
					caractère (.) ou du caractère espace ( ) sont remplacés
					par 3 octets. Donc, quand on lui fournit une chaîne binaire pseudo-aléatoire, la fonction <a
						href="https://www.php.net/manual/fr/function.urlencode.php" target="_blank">urlencode()</a> 
					remplace (256 - (26*2 + 10 + 4))/256 &ap; 75% des octets par 3 octets (les 25% restant ne sont pas modifiés, 
					sauf l'espace qui est transformé en signe plus (+)). <br>Conclusion :
					l'encodage d'une chaine binaire pseudo-aléatoire
					de longueur L avec <a
						href="https://www.php.net/manual/fr/function.urlencode.php" target="_blank">urlencode()</a> donne, en moyenne,
					une chaîne ASCII de longueur<br> (L/4 + 3*3L/4) = 2,5L.
				</p>

				<p class="fp-puce">
					Décommentez maintenant les appels des fonctions <a
						href="https://www.php.net/manual/fr/function.base64-encode.php" target="_blank">base64_encode()</a> et <a
						href="https://www.php.net/manual/fr/function.base64-decode.php" target="_blank">base64_decode()</a>
					dans l'exemple précédent, et vous 
					constaterez que l'appel de <a
						href="https://www.php.net/manual/fr/function.base64-encode.php" target="_blank">base64_encode()</a> avant
					celui de <a
						href="https://www.php.net/manual/fr/function.urlencode.php" target="_blank">urlencode()</a>
					permet de réduire dans des proportions importantes la longueur de la "query string". En effet, le
					passage de la chaine à transmettre par la fonction <a
						href="https://www.php.net/manual/fr/function.base64-encode.php" target="_blank">base64_encode()</a>
					multiplie sa longueur approximativement par 4/3=1,33 (24 bits dans la chaine d'origine, soit 3 octets, 
					sont codés sur 4 octets dans la chaîne encodée en <a href="https://fr.wikipedia.org/wiki/Base64" target="_blank">
					Base64</a>). Mais comme le codage en <a href="https://fr.wikipedia.org/wiki/Base64" target="_blank">
					Base64</a> utilise 65 caractères dont 62 sont alphanumériques, après passage par la fonction <a
						href="https://www.php.net/manual/fr/function.urlencode.php" target="_blank">urlencode()</a>,
					
					on obtient au final une chaîne 
					encodée url de longueur à peine supérieure à la longueur de la chaine encodée en 
					<a href="https://fr.wikipedia.org/wiki/Base64" target="_blank">
					Base64</a>.
						
				</p>
				
				<p class="fp-puce">
					
				</p>

			</section>

			<h4>Signer le cryptage</h4>
			<section>
				<p class="fp-puce">Si nous nous arrêtons au point précédent, certes les données transmises 
					dans la "query string" sont 
					cryptées donc inintelligibles, mais
					nous avons un problème : rien ne garantit que la
					donnée reçue et décryptée est bien la même que celle qui a été
					cryptée et envoyée. On peut toujours modifier manuellement l'url et
					on obtiendra toujours quelque chose au décryptage, même si ce
					quelque chose est totalement incohérent. Dans le cas d'un nombre
					attendu, on pourra, si on reçoit une chaîne non numérique, se douter que l'url a été modifiée, mais dans le
					cas d'une chaîne de caractères attendue, on aura plus de mal à
					définir si on est bien en face d'une tentative de corruption.<br>
					Pour vous en convaincre, essayez, dans l'exemple précédent, de remplacer 
					un caractère par un autre dans la valeur
					d'un couple nom=valeur, avec ou sans appel des fonctions <a
						href="https://www.php.net/manual/fr/function.base64-encode.php" target="_blank">base64_encode()</a> et <a
						href="https://www.php.net/manual/fr/function.base64-decode.php" target="_blank">base64_decode()</a>.
				</p>

				<p class="fp-puce fp-bottom0">
					C'est ici que la signature de données intervient. Avec de tels
					algorithmes ("md5", "sha256", "haval160,4", "crc32", etc) nous allons pouvoir vérifier
					si les données reçues sont bien égales aux données émises. Pour cela :
				</p>
				<ul class="fp-ul-puce">
					<li> on calcule la signature de la chaine cryptée émise;
					<li> on transmet cette signature dans l'url;
					<li> à la réception, on calcule la signature de la chaine cryptée reçue;
					<li> on compare la signature reçue avec la signature calculée à la réception;
					<li> si les 2 signatures sont égales, on considère que la chaine cryptée émise est égale à la chaine cryptée reçue;
					sinon, on est sûr que la "query string" a été modifiée.
				</ul>
				<p class="fp-puce">
					Nous utiliserons la fonction <a
						href="https://www.php.net/manual/fr/function.hash-hmac.php" target="_blank">hash_hmac()</a>
					pour signer nos paramètres. On doit fournir à cette fonction le nom
					de l'algorithme à utiliser. Le choix est très grand : voir la documentation de la fonction <a
					href="https://www.php.net/manual/fr/function.hash-hmac-algos.php" target="_blank">hash_hmac_algos()</a> 
					pour une liste des algorithmes disponibles. 
					Dans l'exemple suivant,
					nous utiliserons l'algorithme de hachage 'sha256'
				    qui renvoie une
					signature de 32 octets (soit 256 bits) de long.
				</p>
				
				<p class="fp-puce">
					Pour utiliser l'algorithme de hachage 'sha256', nous devons générer une clé de 32 octets :
				</p>
				
				<form action="" method="post" class="TEST-form">
					<a class="TEST-lien"
						onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_06.html')"
						title="Afficher la bibliothéque de fonctions"></a>
					<div class="TEST-titre">
						<strong>Exemple</strong> : génération des clés de cryptage et de hachage
					</div>
					<textarea name="txtCode" class="TEST-textarea">
&lt;?php
require('bib_fonctions.php');

htmlDebut('Génération des clés');

htmlInfo('Clé de cryptage encodée en Base64');
echo base64_encode(openssl_random_pseudo_bytes(16));

htmlInfo('Clé de hachage encodée en Base64');
echo base64_encode(openssl_random_pseudo_bytes(32));

htmlFin();
?&gt;</textarea>
</form>
				
				<p class="fp-remarque">
					Un algorithme de hachage renvoie toujours une signature de la
					même longueur, quelque soit la longueur de la chaîne de caractères
					qui est signée.<br>Par exemple sha1 renverra une signature de
					40 octets, sha224 de 56 octets, sha512 de 128 octets,
					md5 de 32 octets, etc.
				</p>

				<p class="fp-puce">Comme la signature est de longueur fixe, nous pouvons également
					la concaténer avec la chaîne cryptée et le vecteur d'initialisation
					<span class="fp-code">$iv</span>, et transmettre le tout dans la valeur
					d'un couple nom=valeur (nous choisissons dans l'exemple ci-dessous de transmettre
					le vecteur d'initialisation suivi de la chaine cryptée au milieu de la signature de 
					la chaine cryptée pour "brouiller les pistes").
				</p>
				
				

				<form action="" method="post" class="TEST-form">
					<a class="TEST-lien"
						onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_06.html')"
						title="Afficher la bibliothéque de fonctions"></a>
					<div class="TEST-titre">
						<strong>Exemple</strong> : paramètres cryptés et signés dans des
						liens
					</div>
					<textarea name="txtCode" class="TEST-textarea">
&lt;?php
require('bib_fonctions.php');

//clés générées avec le script précédent
define('CLE_CRYPTAGE', 'ocKSOzNlBxCu1hsziDoUCQ==');
define('CLE_HACHAGE', 
       'IFQ64afec21PL5xvnv2WyzfUuiDl7n5vwl5GAvuDENA=');

htmlDebut('Paramètres cryptés et signés dans des liens');

if (count($_GET)&gt; 0) {
	afficherReception();
	exit();
}

htmlInfo('Emission');

$lien = $_SERVER['PHP_SELF'];
$lien .= '?x='.crypteSigneURL('François Piat');
$lien .= '&y='.crypteSigneURL('5=4+1');
$lien .= '&z='.crypteSigneURL(12345);

echo '&lt;a href="', $lien, '" target="_blank"&gt;Cliquez ici&lt;/a&gt;';

htmlFin();

/**
 * Affichage des données reçues.
 * 
 * Contrôle de la validité :
 * - du nombre de couple nom=valeur reçus
 * - des noms de ces couples
 * Vérifie que les données reçues sont égales à celles
 * qui ont été émises
 */
function afficherReception() {
	if (count($_GET) != 3){
		echo 'Tentative de piratage ?';
		htmlFin();
		return;
	}
	$t = array('x', 'y', 'z');
	foreach($_GET as $cle =&gt; $val){
		if (! in_array($cle, $t)){
			echo 'Tentative de piratage ?';
			htmlFin();
			return;
		}
		htmlInfo("Réception $cle");
		$r = decrypteSigneURL($val);
		if ($r === FALSE){
			echo 'Tentative de piratage ?';
			htmlFin();
			return;
		}
		echo $r;
	}
	htmlFin();
}

/**
 * Crypte une valeur pour la passer dans une URL.
 *
 * @param mixed		$val	La valeur à crypter
 * @return string	La valeur cryptée encodée url
 */
function crypteSigneURL($val){
	// -- longueur du vecteur d'initialisation
	$ivlen = openssl_cipher_iv_length($cipher='AES-128-CBC');
	// -- génération du vecteur d'initialisation
	$iv = openssl_random_pseudo_bytes($ivlen);
	// -- cryptage de $val
	$x = openssl_encrypt($val, $cipher, 
						 base64_decode(CLE_CRYPTAGE), 
	                     OPENSSL_RAW_DATA, $iv);
	// -- calcul de la signature de la valeur cryptée
	$hmac = hash_hmac('sha256', $x, 
	                  base64_decode(CLE_HACHAGE), true);
	$sha2len=32;
	$x = substr($hmac, 0, $sha2len/2)
	     .$iv.$x.substr($hmac, $sha2len/2);
	$x = base64_encode($x);
	return urlencode($x);
}

/**
 * Décrypte une valeur cryptée avec la fonction crypteSigneURL()
 *
 * @param string	$x	La valeur à décrypter
 * @return mixed	La valeur décryptée ou FALSE si erreur
 */
function decrypteSigneURL($x){
	$ivlen = openssl_cipher_iv_length($cipher='AES-128-CBC');
	$x = base64_decode($x);
	$sha2len=32;
	$hmac = substr($x, 0, $sha2len/2).substr($x, -$sha2len/2);
	$iv = substr($x, $sha2len/2, $ivlen);
	$x = substr($x, $sha2len/2 + $ivlen, -$sha2len/2);
	// calcul de  la signature de la chaine cryptée reçue
	$hmacCalc = hash_hmac('sha256', $x, 
	                      base64_decode(CLE_HACHAGE), true);
	if (! hash_equals($hmac, $hmacCalc)){
		return FALSE;
	}
	return openssl_decrypt($x, $cipher, 
	                       base64_decode(CLE_CRYPTAGE), 
	                       OPENSSL_RAW_DATA, $iv);
}
?&gt;</textarea>
				</form>

				<p class="fp-remarque">Le lien de l'exemple s'ouvrira dans un
					nouvel onglet pour que vous puissiez voir/manipuler l'url.</p>
				<p class="fp-puce">
					La fonction <a
						href="https://www.php.net/manual/fr/function.hash-equals.php" target="_blank">hash_equals()</a>
					compare deux chaînes en utilisant toujours le même temps de calcul, qu'elles soient égales ou pas. Elle
					est utilisée pour ne pas donner d'indications "temporelles" à d'éventuels hackers.<p>
				<p class="fp-remarque">
					Quand PHP compare 2 chaînes avec l'opérateur <span class="fp-code">==</span>,
					le temps de calcul dépend de la position du premier caractère différent dans les 2 chaines; 
					plus le nombre de caractères identiques placés au début des 2 chaines augmente, plus
					la durée de la comparaison augmente.

				</p>

				<p class="fp-puce fp-inter2">Pour éviter d'avoir des urls trop
					longues et avec trop d'éléments et de calcul de cryptage /
					signature à faire, on peut concaténer les valeurs des paramètres
					avec un caractère séparateur comme dans l'exemple suivant.</p>

				<form action="" method="post" class="TEST-form">
					<a class="TEST-lien"
						onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_06.html')"
						title="Afficher la bibliothéque de fonctions"></a>
					<div class="TEST-titre">
						<strong>Exemple</strong> : paramètres cryptés et signés dans des
						liens
					</div>
					<textarea name="txtCode" class="TEST-textarea">
&lt;?php
require('bib_fonctions.php');

//clés générées avec le script précédent
define('CLE_CRYPTAGE', 'ocKSOzNlBxCu1hsziDoUCQ==');
define('CLE_HACHAGE', 
       'IFQ64afec21PL5xvnv2WyzfUuiDl7n5vwl5GAvuDENA=');

htmlDebut('Paramètres cryptés et signés dans des liens');

if (count($_GET)&gt; 0) {
	afficherReception();
	exit();
}

htmlInfo('Emission');

$x = 'François Piat';
$y = '5=4+1';
$z = 12345;

$xyz = crypteSigneURL(implode('|', array($x, $y, $z)));

echo '&lt;hr&gt; DEBUG : strlen($xyz) = ', strlen($xyz) ,'&lt;hr&gt;';

echo '&lt;a href="', $_SERVER['PHP_SELF'], '?xyz=', $xyz,
     '" target="_blank"&gt;Cliquez ici&lt;/a&gt;';

htmlFin();

/**
 * Affichage des données reçues.
 * 
 * Contrôle de la validité :
 * - du nombre de couple nom=valeur reçus
 * - du nom du couple attendu
 * Vérifie que les données reçues sont égales à celles
 * qui ont été émises
 */
function afficherReception() {
	if (count($_GET) != 1){
		echo 'Tentative de piratage ?';
		htmlFin();
		return;
	}
	if (!isset($_GET['xyz'])){
		echo 'Tentative de piratage ?';
		htmlFin();
		return;
	}
	$xyz = decrypteSigneURL($_GET['xyz']);
	if ($xyz === FALSE){
		echo 'Tentative de piratage ?';
		htmlFin();
		return;
	}
	$xyz = explode('|', $xyz);
	// on n'est jamais trop prudent !
	if (count($xyz) != 3){
		echo 'Tentative de piratage ?';
		htmlFin();
		return;
	}
	list($x, $y, $z) = $xyz;
	
	htmlInfo('Réception x');
	echo $x;
	htmlInfo('Réception y');
	echo $y;
	htmlInfo('Réception z');
	echo $z;
	
	htmlFin();
}

/**
 * Crypte une valeur pour la passer dans une URL.
 *
 * @param mixed		$val	La valeur à crypter
 * @return string	La valeur cryptée encodée url
 */
function crypteSigneURL($val){
	// -- longueur du vecteur d'initialisation
	$ivlen = openssl_cipher_iv_length($cipher='AES-128-CBC');
	// -- génération du vecteur d'initialisation
	$iv = openssl_random_pseudo_bytes($ivlen);
	// -- cryptage de $val
	$x = openssl_encrypt($val, $cipher, 
						 base64_decode(CLE_CRYPTAGE), 
	                     OPENSSL_RAW_DATA, $iv);
	// -- calcul de la signature de la valeur cryptée
	$hmac = hash_hmac('sha256', $x, 
	                  base64_decode(CLE_HACHAGE), true);
	$sha2len=32;
	$x = substr($hmac, 0, $sha2len/2)
	     .$iv.$x.substr($hmac, $sha2len/2);
	$x = base64_encode($x);
	return urlencode($x);
}

/**
 * Décrypte une valeur cryptée avec la fonction crypteSigneURL()
 *
 * @param string	$x	La valeur à décrypter
 * @return mixed	La valeur décryptée ou FALSE si erreur
 */
function decrypteSigneURL($x){
	$ivlen = openssl_cipher_iv_length($cipher='AES-128-CBC');
	$x = base64_decode($x);
	$sha2len=32;
	$hmac = substr($x, 0, $sha2len/2).substr($x, -$sha2len/2);
	$iv = substr($x, $sha2len/2, $ivlen);
	$x = substr($x, $sha2len/2 + $ivlen, -$sha2len/2);
	// calcul de  la signature de la chaine cryptée reçue
	$hmacCalc = hash_hmac('sha256', $x, 
	                      base64_decode(CLE_HACHAGE), true);
	if (! hash_equals($hmac, $hmacCalc)){
		return FALSE;
	}
	return openssl_decrypt($x, $cipher, 
	                       base64_decode(CLE_CRYPTAGE), 
	                       OPENSSL_RAW_DATA, $iv);
}
?&gt;</textarea>
				</form>

				<p class="fp-remarque">Le lien de l'exemple s'ouvrira dans un
					nouvel onglet pour que vous puissiez voir/manipuler l'url.</p>
					
				<p class="fp-puce fp-inter2">
					La version 7.1 de PHP a ajouté des paramètres aux fonctions <a
						href="https://www.php.net/manual/fr/function.openssl-encrypt.php" target="_blank">openssl_encrypt()</a>
					et <a
						href="https://www.php.net/manual/fr/function.openssl-decrypt.php" target="_blank">openssl_decrypt()</a>
					
					permettant d'<b>authentifier</b> la chaine cryptée lors du décryptage.<br>
					La fonction <a
						href="https://www.php.net/manual/fr/function.openssl-encrypt.php" target="_blank">openssl_encrypt()</a>
					renvoie toujours la chaine cryptée, et on récupère, dans
					la chaîne <span class="fp-code">$tag</span> transmise par référence, une chaine
					permettant d'<b>authentifier</b> la chaine cryptée reçue.
					Notez bien que la fonction <a
						href="https://www.php.net/manual/fr/function.openssl-encrypt.php" target="_blank">openssl_encrypt()</a>
					écrit dans <span class="fp-code">$tag</span>.<br>
					Cette chaîne <span class="fp-code">$tag</span> doit ensuite être transmise à la fonction <a
						href="https://www.php.net/manual/fr/function.openssl-decrypt.php" target="_blank">openssl_decrypt()</a>
					qui va la lire afin d'authentifier la chaîne cryptée reçue. 
					
				</p>
				
				<p class="fp-puce">
					Pour pouvoir utiliser ces paramètres supplémentaires et donc le paramètre supplémentaire
					<span class="fp-code">$tag</span>, il faut utiliser un algorithme
					en mode AEAD (GCM ou CCM).
				</p>
				<p class="fp-puce">
					
				</p>
				<p class="fp-puce">
					Dans l'exemple suivant, on utilise toujours l'algorithme AES-128, mais cette fois-ci en mode GCM : il 
					<b>crypte ET signe</b> les données. La fonction <a
						href="https://www.php.net/manual/fr/function.openssl-encrypt.php" target="_blank">openssl_encrypt()</a>
					permet de fixer la longueur du tag d'authentification. Sa valeur peut être entre 4 et 16 pour le mode GCM. 
					Dans l'exemple suivant, on utilise la valeur par défaut du paramètre correspondant : 
					le tag d'authentification
					a une longueur fixe égale à 16 octets.
					
				</p>
				
				<form action="" method="post" class="TEST-form">
					<a class="TEST-lien"
						onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_06.html')"
						title="Afficher la bibliothéque de fonctions"></a>
					<div class="TEST-titre">
						<strong>Exemple</strong> : paramètres cryptés et signés dans des
						liens
					</div>
				<textarea name="txtCode" class="TEST-textarea">
&lt;?php
require('bib_fonctions.php');

define('CLE_CRYPTAGE', 'ocKSOzNlBxCu1hsziDoUCQ==');

htmlDebut('Paramètres cryptés et signés dans des liens');

if (count($_GET)&gt; 0) {
	afficherReception();
	exit();
}

htmlInfo('Emission');

$x = 'François Piat';
$y = '5=4+1';
$z = 12345;

$xyz = crypteSigneURL(implode('|', array($x, $y, $z)));

echo '&lt;hr&gt; DEBUG : strlen($xyz) = ', strlen($xyz) ,'&lt;hr&gt;';

echo '&lt;a href="', $_SERVER['PHP_SELF'], '?xyz=', $xyz,
     '" target="_blank"&gt;Cliquez ici&lt;/a&gt;';

htmlFin();

/**
 * Affichage des données reçues.
 * 
 * Contrôle de la validité :
 * - du nombre de couple nom=valeur reçus
 * - du nom du couple attendu
 * Vérifie que les données reçues sont égales à celles
 * qui ont été émises
 */
function afficherReception() {
	if (count($_GET) != 1){
		echo 'Tentative de piratage ?';
		htmlFin();
		return;
	}
	if (!isset($_GET['xyz'])){
		echo 'Tentative de piratage ?';
		htmlFin();
		return;
	}
	$xyz = decrypteSigneURL($_GET['xyz']);
	if ($xyz === FALSE){
		echo 'Tentative de piratage ?';
		htmlFin();
		return;
	}
	$xyz = explode('|', $xyz);
	// on n'est jamais trop prudent !
	if (count($xyz) != 3){
		echo 'Tentative de piratage ?';
		htmlFin();
		return;
	}
	list($x, $y, $z) = $xyz;
	
	htmlInfo('Réception x');
	echo $x;
	htmlInfo('Réception y');
	echo $y;
	htmlInfo('Réception z');
	echo $z;
	
	htmlFin();
}

/**
 * Crypte une valeur pour la passer dans une URL.
 *
 * @param mixed		$val	La valeur à crypter
 * @return string	La valeur cryptée encodée url
 */
function crypteSigneURL($val){
	$ivlen = openssl_cipher_iv_length($cipher='aes-128-gcm');
	$iv = openssl_random_pseudo_bytes($ivlen);
	// $tag (tag d'authentification)
	// est une chaîne transmise par référence
	$x = openssl_encrypt($val, $cipher, 
						 base64_decode(CLE_CRYPTAGE), 
	                     OPENSSL_RAW_DATA, $iv, $tag);
	$x = $iv.$tag.$x;
	$x = base64_encode($x);
	return urlencode($x);
}

/**
 * Décrypte une valeur cryptée avec la fonction crypteSigneURL()
 *
 * @param string	$x	La valeur à décrypter
 * @return mixed	La valeur décryptée ou FALSE si erreur
 */
function decrypteSigneURL($x){
	$x = base64_decode($x);
	$ivlen = openssl_cipher_iv_length($cipher='aes-128-gcm');
	$iv = substr($x, 0, $ivlen);
	$taglen = 16;
	$tag = substr($x, $ivlen, $taglen);
	$x = substr($x, $ivlen + $taglen);
	return openssl_decrypt($x, $cipher, 
	                       base64_decode(CLE_CRYPTAGE), 
						   OPENSSL_RAW_DATA, $iv, $tag);
}
?&gt;</textarea>
				</form>

				<p class="fp-remarque">Le lien de l'exemple s'ouvrira dans un
					nouvel onglet pour que vous puissiez voir/manipuler l'url.</p>
				
			</section>
		</section>
		
		
	</div>
	<footer></footer>
</body>
</html>