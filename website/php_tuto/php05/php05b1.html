<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>Les tableaux</title>
<link rel="stylesheet" href="../_local/codemirror.css">
<script src="../_local/codemirror_pour_php.js"></script>

<link rel="stylesheet" href="../_core/def.css">
<script>
	if (top.FP) {
		document.addEventListener('DOMContentLoaded', top.FP.initPage, false);
	} else {
		location.replace('../index.html?x=' + encodeURI(location.href));
	}
</script>
</head>
<body>
	<div id="MENU-top"></div>
	<nav id="MENU-tuto"></nav>

	<div id="PAGE-tuto">
		<header></header>
		<ul id="MENU-page"></ul>

		<p>Très souvent, le travail principal avec un tableau consiste à
			exécuter des itérations pour traiter chacun des éléments du tableau.
			Comme à son habitude, PHP propose plusieurs méthodes pour exécuter
			des boucles, et le choix du bon type de boucle dépend du type de
			tableau à traiter.</p>

		<p class="fp-puce">
			Une boucle exécutée avec <span class="fp-code">foreach</span> est
			particulièrement utile avec un tableau associatif. Tous les éléments
			du tableau sont traités sans que nous ayons besoin d'en connaître la
			clé.
		</p>
		<p class="fp-puce">
			<span class="fp-code">foreach</span> est utilisable aussi avec tous
			les tableaux à indices numériques, surtout dans le cas où nous ne pouvons
			pas garantir que les indices du tableau sont bien des entiers
			consécutifs.
		</p>
		<p class="fp-puce">Il existe 4 syntaxes de l'instruction <span class="fp-code">foreach</span>.
		</p>

		<h3>Accès en consultation aux valeurs</h3>
		<section>
		<pre data-code="PHP">
foreach ($tableau as $valeurElt) {
	instructions
}
</pre>
		<p>
		Avec cette syntaxe, à chaque itération, <span class="fp-code">$valeurElt</span> reçoit une
		<b>copie</b> de la valeur de l'élément courant. Donc, si on modifie <span class="fp-code">$valeurElt</span>,
		cette modification n'est pas répercutée dans le tableau parcouru.
		</p>
		<form action="" method="post" class="TEST-form">
			<a class="TEST-lien"
				onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_04.html')"
				title="Afficher la bibliothéque de fonctions"></a>
			<div class="TEST-titre">
				<strong>Exemple</strong> : foreach consultation valeur
			</div>
			<textarea name="txtCode" class="TEST-textarea">&lt;?php
require('bib_fonctions.php');

htmlDebut('Boucle avec foreach');

htmlInfo('foreach avec un tableau associatif');

$ta['B41d'] = 'Pierre';
$ta['C24a'] = 'Paul';
$ta['D12z'] = 'Jacques';

foreach ($ta as $valeurElt) {
	echo '&lt;br&gt;Valeur = ', $valeurElt;
}


htmlInfo('foreach avec un tableau à trous');

$ti[0] = 50;
$ti[3] = 60;
$ti[6] = 407;

foreach ($ti as $valeurElt) {
	echo '&lt;br&gt;++$valeurElt = ', ++$valeurElt;
}

echo '&lt;pre&gt;', print_r($ti, true), '&lt;/pre&gt;';

htmlFin();
?&gt;</textarea>
		</form>
		</section>
		
		
		
		
		<h3>Accès en consultation aux clés et aux valeurs</h3>
		<section>
			<pre data-code="PHP">
foreach ($tableau as $cle =&gt; $valeurElt) {
	instructions
}
</pre>
		<p>
		Avec cette syntaxe, à chaque itération, <span class="fp-code">$valeurElt</span> reçoit toujours une
		<b>copie</b> de la valeur de l'élément courant, et <span class="fp-code">$cle</span> reçoit également
		une copie de valeur de la clé de l'élément courant.
		</p>

			<form action="" method="post" class="TEST-form">
				<div class="TEST-titre">
					<a class="TEST-lien"
						onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_04.html')"
						title="Afficher la bibliothéque de fonctions"></a> <strong>Exemple</strong>
					: foreach consultation clé et valeur
				</div>
				<textarea name="txtCode" class="TEST-textarea">&lt;?php
require('bib_fonctions.php');

htmlDebut('Boucle avec foreach');

htmlInfo('foreach avec un tableau associatif');

$ta['B41d'] = 'Pierre';
$ta['C24a'] = 'Paul';
$ta['D12z'] = 'Jacques';

foreach ($ta as $cle =&gt; $valeurElt) {
	echo '&lt;br&gt;Clé = ', $cle, ' | Valeur = ', $valeurElt;
}

htmlInfo('foreach avec un tableau à trous');

$ti[0] = 50;
$ti[3] = 60;
$ti[6] = 407;

foreach ($ti as $cle =&gt; $valeurElt) {
	echo '&lt;br&gt;++$cle = ', ++$cle, ' | ++$valeurElt = ', 
	++$valeurElt;
}

echo '&lt;pre&gt;', print_r($ti, true), '&lt;/pre&gt;';

htmlFin();
?&gt;</textarea>
			</form>
		</section>

<h3>Accès en consultation et en modification aux valeurs</h3>
		<section>
		<p> Pour accéder en consultation et en <b>modification</b> aux valeurs, on peut utiliser 2 syntaxes.
		</p>
		<p class="fp-puce">
			La première :
		</p>
			<pre data-code="PHP">
foreach ($tableau as &amp;$valeurElt) {
	instructions
}
</pre>
		<p>
		Avec cette syntaxe, à chaque itération, <span class="fp-code">$valeurElt</span> reçoit une
		<b>référence</b> sur la valeur de l'élément courant. Donc, si on modifie <span class="fp-code">$valeurElt</span>,
		la valeur de l'élément courant est modifiée dans le tableau parcouru.
		</p>

			<form action="" method="post" class="TEST-form">
				<div class="TEST-titre">
					<a class="TEST-lien"
						onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_04.html')"
						title="Afficher la bibliothéque de fonctions"></a> <strong>Exemple</strong>
					: foreach modification valeur (1ère syntaxe)
				</div>
				<textarea name="txtCode" class="TEST-textarea">&lt;?php
require('bib_fonctions.php');

htmlInfo('foreach avec un tableau à trous');
$ti[0] = 50;
$ti[3] = 60;
$ti[6] = 407;

foreach ($ti as &amp;$valeurElt) {
	echo '&lt;br&gt;++$valeurElt = ', ++$valeurElt;
}
unset($valeurElt);

echo '&lt;pre&gt;', print_r($ti, true), '&lt;/pre&gt;';

htmlFin();
?&gt;</textarea>
			</form>
		
		<p class="fp-puce">
			La deuxième :
		</p>
			<pre data-code="PHP">
foreach ($tableau as $cle =&gt; &amp;$valeurElt) {
	instructions
}
</pre>
		<p>
		Avec cette syntaxe, à chaque itération, <span class="fp-code">$valeurElt</span> reçoit toujours une
		<b>référence</b> sur la valeur de l'élément courant, et <span class="fp-code">$cle</span> reçoit
		une copie de la valeur de la clé de l'élément courant.
		Donc, si on modifie <span class="fp-code">$valeurElt</span>,
		la valeur de l'élément courant est modifiée dans le tableau parcouru.
		</p>

			<form action="" method="post" class="TEST-form">
				<div class="TEST-titre">
					<a class="TEST-lien"
						onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_04.html')"
						title="Afficher la bibliothéque de fonctions"></a> <strong>Exemple</strong>
					: foreach modification valeur (2ère syntaxe)
				</div>
				<textarea name="txtCode" class="TEST-textarea">&lt;?php
require('bib_fonctions.php');

htmlInfo('foreach avec un tableau à trous');
$ti[0] = 50;
$ti[3] = 60;
$ti[6] = 407;

foreach ($ti as $cle =&gt; &amp;$valeurElt) {
	echo '&lt;br&gt;++$cle = ', ++$cle, ' | ++$valeurElt = ', 
	++$valeurElt;
}
unset($valeurElt);

echo '&lt;pre&gt;', print_r($ti, true), '&lt;/pre&gt;';

htmlFin();
?&gt;</textarea>
			</form>
		
		<p class="fp-rouge" style="border: 1px solid; padding: 4px">
			Notez la présence de l'instruction <span class="fp-code">unset($valeurElt);</span>
			dans les deux exemples précédents qui permet de détruire la référence sur la valeur
			du dernier élément du tableau. Sans cette instruction, si on modifie <span class="fp-code">$valeurElt</span>
			après la boucle, on modifie la valeur du dernier élément du tableau, ... la plupart du temps sans le
			souhaiter ! Donc, faîtes attention à <b>ne pas oublier</b> le <b><span class="fp-code">unset($valeurElt);</span></b>.
		</p>
			
			
			
		</section>

		<h3>Modification du tableau parcouru lors d'un accès en consultation</h3>
		<section>
			<p>
				Lorsqu'on utilise une boucle <span class="fp-code">foreach</span>
				sans mettre un <span class="fp-code">&amp;</span> devant <span class="fp-code">$valeurElt</span>, 
				si on modifie "directement" le tableau parcouru dans la boucle, une copie du tableau est effectuée
				et les modifications ne sont pas visibles dans la boucle.
			</p>
				Attention à l'utilisation de ce mécanisme si vous utilisez <span
					class="fp-code">foreach</span> avec des tableaux de grande taille
				car la copie occupe de la place en mémoire.
			</p>

			<form action="" method="post" class="TEST-form">
				<a class="TEST-lien"
					onclick="top.FP.Voir.showPLUS('exemple/bib_fonctions_04.html')"
					title="Afficher la bibliothéque de fonctions"></a>
				<div class="TEST-titre">
					<strong>Exemple</strong> : boucle avec modification
				</div>
				<textarea name="txtCode" class="TEST-textarea" cols="55" rows="40">
&lt;?php
require('bib_fonctions.php');

htmlDebut('Boucle avec modification');

$t['B41d'] = 'Pierre';
$t['C24a'] = 'Paul';
$t['D12z'] = 'Jacques';

htmlInfo('Tableau originel');
infoTableau($t);

htmlInfo('foreach : accès en consultation');

foreach ($t as $cle =&gt; $val) {
	if ($val == 'Pierre'){
		$t['C24a'] .= 'o';
		unset($t['D12z']);
    }
	echo '&lt;br&gt;Clé = ', $cle, ' | Valeur = ', $val;
}

htmlInfo('Tableau après la boucle');
infoTableau($t);

htmlFin();
?&gt;</textarea>
			</form>
		</section>
	</div>
	<footer></footer>
</body>
</html>